# Задача 1: Обедающие философы (Dining Philosophers)

## Постановка задачи

5 философов сидят за круглым столом. Между ними лежат 5 вилок.  
Чтобы поесть, философу нужны две вилки: левая и правая.  
Философы попеременно:
- думают (вилки не нужны)
- едят (нужны обе вилки)

Необходимо:
1) Реализовать решение, приводящее к взаимоблокировке (deadlock).
2) Реализовать исправленное решение, исключающее deadlock.

## Структура

```
Task1/
  Task1.cs                 - Запуск двух сценариев: с deadlock и без
  PhilosopherDeadlock.cs   - Философ с реализацией, приводящей к взаимоблокировке
  PhilosopherNoDeadlock.cs - Философ с корректной синхронизацией
  README.md                - Описание задачи
```

## Реализация с deadlock

Неправильный алгоритм (одинаковый для всех философов):

1) Взять левую вилку (`lock(_leftFork)`).
2) Взять правую вилку (`lock(_rightFork)`).
3) Поесть.
4) Положить вилки (выход из блокировок).

Сценарий deadlock:
- Все философы одновременно берут левую вилку.
- Каждый пытается взять правую вилку.
- Правая вилка каждого уже занята соседом.
- Никто не может продолжить — взаимоблокировка.

## Реализация без deadlock

Ключевые приёмы:

1) Разный порядок захвата вилок:
   - Чётные философы: сначала левая, потом правая.
   - Нечётные философы: сначала правая, потом левая.

2) Использование `Semaphore` вместо `lock` для вилок:
   - Каждая вилка представлена `new Semaphore(1, 1)`.
   - Попытка захвата с таймаутом (например, 100 мс).

3) Откат при неудаче:
   - Если вторую вилку взять не удалось — отпускаем первую, ждём и пробуем снова.

Такое решение ломает циклическую зависимость и предотвращает бесконечное ожидание.

## Как запустить задачу 1

Из `Program.cs`:
```
var task1 = new Lab4.Task1.Task1();
task1.RunWithDeadlock();      // Показать взаимоблокировку
task1.RunWithoutDeadlock();   // Показать корректную работу
```
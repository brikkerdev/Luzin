# Лабораторная работа №4
## Проблемы синхронизации потоков

### Цель работы
Изучить проблему синхронизации потоков, научиться выявлять и предотвращать взаимоблокировки (deadlock).

## Описание решений задач

### Задача 1: Обедающие философы (Dining Philosophers)

#### Постановка задачи
5 философов сидят за круглым столом. Перед каждым философом лежит одна вилка (всего 5 вилок). Чтобы поесть, философу нужны ДВЕ вилки: левая и правая. Философы чередуют два состояния:
- **Думать** (не требует вилок)
- **Есть** (требует две вилки)

#### Реализация с Deadlock

**Алгоритм (неправильный):**
1. Философ берёт левую вилку (`lock(_leftFork)`)
2. Философ берёт правую вилку (`lock(_rightFork)`)
3. Философ ест
4. Философ отпускает вилки

**Проблема (deadlock сценарий):**
1. Все 5 философов одновременно берут свои левые вилки
2. Каждый философ пытается взять правую вилку
3. Правая вилка каждого философа занята соседом справа
4. **Результат**: Вечная блокировка - каждый ждет вилку, которую держит другой

#### Реализация без Deadlock

**Исправленный алгоритм:**
1. **Разный порядок взятия вилок**:
   - Чётные философы (0, 2, 4): сначала левая, потом правая
   - Нечётные философы (1, 3): сначала правая, потом левая
2. **Использование таймаутов**: Если вилку не удалось взять за 100 мс - отпускаем уже взятую вилку
3. **Использование Semaphore**: Вместо `lock` используем `Semaphore` с ограниченным временем ожидания

**Преимущества решения:**
- Ломает циклическую зависимость
- Предотвращает бесконечное ожидание
- Гарантирует прогресс системы

### Задача 2: Спящий парикмахер (Sleeping Barber)

#### Постановка задачи
Парикмахерская работает по принципу:
1. Парикмахер спит, когда нет клиентов
2. Когда приходит клиент, парикмахер просыпается и начинает стрижку
3. Если во время стрижки приходят новые клиенты, они садятся в очередь
4. Очередь имеет ограниченный размер
5. Если очередь полна, новые клиенты уходят

#### Реализация

**Основные компоненты:**
- **Парикмахер** (отдельный поток):
  - Проверяет наличие клиентов
  - Спит при отсутствии клиентов (ожидает на семафоре)
  - Стрижет клиентов по одному
- **Генератор клиентов** (отдельный поток):
  - Создаёт новых клиентов через случайные интервалы
  - Добавляет клиентов в очередь
  - Будит парикмахера при появлении первого клиента
- **Очередь клиентов**:
  - Ограниченный размер (обычно 5 мест)
  - Защищена `Mutex` от одновременного доступа

**Синхронизация:**
- `Semaphore customerSemaphore`: Считает количество клиентов в очереди
- `Semaphore barberSemaphore`: Пробуждает парикмахера
- `Mutex queueMutex`: Защищает очередь клиентов

### Задача 3: Производитель–Потребитель (Producer–Consumer)

#### Постановка задачи
Есть общий буфер (очередь) ограниченного размера. Два типа потоков:
- **Производители**: добавляют товары в буфер
- **Потребители**: забирают товары из буфера

#### Требования к синхронизации
1. **Производитель не должен переполнять буфер**
2. **Потребитель не должен пытаться взять из пустого буфера**
3. **Доступ к буферу должен быть потокобезопасным**

#### Реализация

**Классическое решение с тремя семафорами:**
1. **emptyCount** (`Semaphore spacesAvailable`):
   - Считает свободные места в буфере
   - Изначально равен размеру буфера
   - Производитель ждёт этот семафор перед добавлением
2. **fullCount** (`Semaphore itemsAvailable`):
   - Считает занятые места в буфере
   - Изначально равен 0
   - Потребитель ждёт этот семафор перед извлечением
3. **mutex** (`Mutex bufferLock`):
   - Обеспечивает эксклюзивный доступ к буферу
   - Защищает от race condition

**Алгоритм производителя:**
1. `spacesAvailable.WaitOne()` - ждём свободное место
2. `bufferLock.WaitOne()` - захватываем мьютекс
3. Добавляем товар в буфер
4. `bufferLock.ReleaseMutex()` - отпускаем мьютекс
5. `itemsAvailable.Release()` - сигнализируем о новом товаре

**Алгоритм потребителя:**
1. `itemsAvailable.WaitOne()` - ждём доступный товар
2. `bufferLock.WaitOne()` - захватываем мьютекс
3. Извлекаем товар из буфера
4. `bufferLock.ReleaseMutex()` - отпускаем мьютекс
5. `spacesAvailable.Release()` - сигнализируем о свободном месте

### Как запустить задачи

```csharp
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("=== ЛАБОРАТОРНАЯ РАБОТА 4 ===");

        // Задача 1: Обедающие философы
        Console.WriteLine("\n1. Обедающие философы:");
        Task1 task1 = new Task1();
        task1.RunWithDeadlock();      // Демонстрация deadlock
        task1.RunWithoutDeadlock();   // Корректная работа

        // Задача 2: Спящий парикмахер
        Console.WriteLine("\n\n2. Спящий парикмахер:");
        Task2 task2 = new Task2(maxQueueSize: 5);
        task2.Run();

        // Задача 3: Производитель-Потребитель
        Console.WriteLine("\n\n3. Производитель-Потребитель:");
        Task3 task3 = new Task3(bufferSize: 5);
        task3.Run(producerCount: 2, consumerCount: 2);

        Console.WriteLine("\nВсе задачи завершены!");
        Console.ReadKey();
    }
}
# Задача 3: Производитель – Потребитель (Producer – Consumer)

## Постановка задачи

Есть общий буфер (очередь) ограниченного размера.

Два типа потоков:
- Производители (producers) — добавляют элементы в буфер.
- Потребители (consumers) — извлекают элементы из буфера.

Необходимо обеспечить:
1) Производитель не переполняет буфер (не добавляет, пока нет свободного места).
2) Потребитель не читает из пустого буфера.
3) Доступ к буферу потокобезопасен.

## Структура
```
Task3/
  Task3.cs   - Реализация буфера, производителей и потребителей
  README.md  - Описание задачи
```
## Классическое решение с тремя примитивами

### Примитивы

1) `Semaphore spacesAvailable`
   - Считает количество свободных мест в буфере (emptyCount).
   - Изначально равно размеру буфера.
   - Производитель вызывает `WaitOne()` перед добавлением элемента.

2) `Semaphore itemsAvailable`
   - Считает количество занятых мест в буфере (fullCount).
   - Изначально равно 0.
   - Потребитель вызывает `WaitOne()` перед извлечением элемента.

3) `Mutex` (или `lock`) `bufferLock`
   - Обеспечивает взаимное исключение при доступе к самому буферу.
   - Защищает от гонок (race conditions).

### Алгоритм производителя

1) `spacesAvailable.WaitOne();`    // Ждём свободное место.
2) Захватываем `bufferLock`.       // Входим в критическую секцию.
3) Кладём элемент в буфер.
4) Отпускаем `bufferLock`.         // Выходим из критической секции.
5) `itemsAvailable.Release();`     // Сигнализируем, что появился новый элемент.

### Алгоритм потребителя

1) `itemsAvailable.WaitOne();`     // Ждём, пока появится хотя бы один элемент.
2) Захватываем `bufferLock`.       // Входим в критическую секцию.
3) Извлекаем элемент из буфера.
4) Отпускаем `bufferLock`.         // Выходим из критической секции.
5) `spacesAvailable.Release();`    // Сигнализируем, что освободилось место.

## Как запустить задачу 3

Из `Program.cs`:
```
var task3 = new Lab4.Task3.Task3(bufferSize: 5);
task3.Run(producerCount: 2, consumerCount: 2);
```